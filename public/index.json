[{"content":"\rI\u0026rsquo;ve come up with the idea of starting a series of articles on programming, specifically aimed at addressing the questions I encountered as a beginner on my JavaScript journey\nThis includes things that might seem evident or trivial, but are not so obvious for a beginner.\nSometimes, knowing how to use things is sufficient, but there are people who feel frustrated when they don\u0026rsquo;t fully understand how these things work. Because of this lack of understanding, they often find themselves stuck. I am one of these people\nThese articles are the result of all my personal notes that I\u0026rsquo;ve compiled over months.\nThis blog also serves as a my online knowledge base.\nI\u0026rsquo;m convinced, as a learner myself, that some of these posts may be of great help to you if you\u0026rsquo;re just starting to learn JavaScript in 2023/2024 and have no prior programming experience.\n","permalink":"https://hub.visualartisan.fr/posts/javascript-fundamentals/","summary":"I\u0026rsquo;ve come up with the idea of starting a series of articles on programming, specifically aimed at addressing the questions I encountered as a beginner on my JavaScript journey\nThis includes things that might seem evident or trivial, but are not so obvious for a beginner.\nSometimes, knowing how to use things is sufficient, but there are people who feel frustrated when they don\u0026rsquo;t fully understand how these things work.","title":"JavaScript Fundamentals"},{"content":"In JavaScript, short-circuiting is a technique that uses the lazy evaluation of logical operators like \u0026amp;\u0026amp; (logical AND) and || (logical OR) to execute a conditional expression.\nConsider the following example, where if the condition is true, nextSlide() is called:\nif (e.key === \u0026#34;ArrowRight\u0026#34;) { nextSlide(); } Using short-circuiting, the same logic can be written more concisely:\ne.key === \u0026#34;ArrowRight\u0026#34; \u0026amp;\u0026amp; nextSlide(); Here\u0026rsquo;s how the short-circuiting works in this expression:\ne.key === 'ArrowRight' is evaluated first. If this condition is false, the whole expression is immediately seen as false, and the code proceeds to the next instruction. nextSlide() isn\u0026rsquo;t even evaluated. If the first condition is true, the next part of the expression is evaluated. In this case, nextSlide() is called. This mechanism can be useful for making code more readable and concise.\n","permalink":"https://hub.visualartisan.fr/posts/shortcircuiting/","summary":"In JavaScript, short-circuiting is a technique that uses the lazy evaluation of logical operators like \u0026amp;\u0026amp; (logical AND) and || (logical OR) to execute a conditional expression.\nConsider the following example, where if the condition is true, nextSlide() is called:\nif (e.key === \u0026#34;ArrowRight\u0026#34;) { nextSlide(); } Using short-circuiting, the same logic can be written more concisely:\ne.key === \u0026#34;ArrowRight\u0026#34; \u0026amp;\u0026amp; nextSlide(); Here\u0026rsquo;s how the short-circuiting works in this expression:","title":"Short-circuit evaluation in JavaScript"},{"content":"Async/await : the differences, and when and why to choose one over the other Advantages of async/await\nReadability: Code written with async/await often looks more synchronous and is easier to follow, making it generally more readable. Error Handling: You can use try/catch blocks to handle both synchronous and asynchronous errors, which can make error-handling logic more straightforward. Debugging: Debugging is often easier with async/await because it allows you to step through your code just like you would with synchronous code. async function fetchData() { try { const response = await fetch(\u0026#34;https://api.example.com/data\u0026#34;); const data = await response.json(); console.log(data); } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); } } Advantages of .then()\nComposability: Promises are composable, meaning you can combine them in sophisticated ways using Promise.all(), Promise.race(), etc.\nFlexibility: .then() can be more flexible for complex chains of asynchronous operations where you might not want to stop the entire chain if one operation fails.\nfetch(\u0026#34;https://api.example.com/data\u0026#34;) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; { console.log(data); return anotherAsyncFunction(data); }) .then((result) =\u0026gt; console.log(result)) .catch((error) =\u0026gt; console.error(\u0026#34;Error:\u0026#34;, error)); When to Use Which\nUse async/await when: You have a series of asynchronous operations that depend on the previous one to complete, and you want more readable and maintainable code. Use .then() when: You\u0026rsquo;re dealing with multiple asynchronous operations that are independent of each other, or you\u0026rsquo;re using libraries that return promises but are not async/await friendly. To deepen your understanding, you may find these articles helpful:\nJavaScript.info: Async/await MDN Web Docs: async function MDN Web Docs: Promise ","permalink":"https://hub.visualartisan.fr/posts/async-await/","summary":"Async/await : the differences, and when and why to choose one over the other Advantages of async/await\nReadability: Code written with async/await often looks more synchronous and is easier to follow, making it generally more readable. Error Handling: You can use try/catch blocks to handle both synchronous and asynchronous errors, which can make error-handling logic more straightforward. Debugging: Debugging is often easier with async/await because it allows you to step through your code just like you would with synchronous code.","title":"Async/await VS .then() method"},{"content":"\ri = i+1 vs i++ and Side Effects i++ and i = i + 1 are quite similar in that they both increase the value of i by 1. However, there are some subtle differences between them, especially when used in more complex expressions.\ni++ (Postfix Increment)\nlet i = 0; let a = i++; // a takes the value 0, and i is now 1 The value of i is increased by 1. The expression itself evaluates to the original value of i before the incrementation. i = i + 1\nlet i = 0; let a = (i = i + 1); // a takes the value 1, and i is now 1 The value of i is increased by 1. The expression itself evaluates to the new value of i. Here\u0026rsquo;s an example to illustrate the difference:\nlet i = 0; let j = 0; let a = i++; // a takes the value 0, i becomes 1 let b = (j = j + 1); // b takes the value 1, j becomes 1 console.log(a); // Displays 0 console.log(b); // Displays 1 In most cases, you can use these two methods interchangeably if you don\u0026rsquo;t care about the value the expression evaluates to.\nThe postfix increment operator i++ increases the value of i by 1 but returns the original value of i before the incrementation. This is what\u0026rsquo;s known as a \u0026ldquo;side effect\u0026rdquo;: the expression does something (changes i) while evaluating to a value (the old value of i).\nHere\u0026rsquo;s how it works step by step:\ni is initialized to 0. a = i++ is executed. The current value of i (which is 0) is assigned to a. Then, i is increased by 1 (now i is 1). In other words, the operation i++ does two things:\nIt returns the current value of i (which will be assigned to a). It increments the value of i. That\u0026rsquo;s why, after executing a = i++ with i initialized to 0, a will be 0 and i will be 1.\n","permalink":"https://hub.visualartisan.fr/posts/sideeffect/","summary":"i = i+1 vs i++ and Side Effects i++ and i = i + 1 are quite similar in that they both increase the value of i by 1. However, there are some subtle differences between them, especially when used in more complex expressions.\ni++ (Postfix Increment)\nlet i = 0; let a = i++; // a takes the value 0, and i is now 1 The value of i is increased by 1.","title":"i+1 vs i++ and side effect"}]