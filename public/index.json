[{"content":"\rJe rencontrais souvent sur CodePen du SASS, SCSS , Less, Stylus etc.\nJ\u0026rsquo;avais une idée générale que cela représentait une autre syntaxe CSS, sans jamais m\u0026rsquo;y être vraiment intéressé et faute d\u0026rsquo;y voir un intérêt immédiat pour mes projets.\nUne fois lancé dans des projets plus complexes, je me suis dit que ce serait bien de séparer mon CSS, afin d\u0026rsquo;avoir une meilleure lisibilité et une meilleure gestion. Ce sont les principales raisons qui m\u0026rsquo;ont poussé à essayer un préprocesseur CSS.\nBref, j\u0026rsquo;ai décidé d\u0026rsquo;essayer, mon choix s\u0026rsquo;est porté sur SASS : j\u0026rsquo;ai adoré et tout de suite accroché !\nUn préprocesseur CSS, dont vous ne pourrez bientôt plus vous passer! Son système de variables, bien que similaire à certaines fonctionnalités du CSS vanilla, son système de mixins, de nesting (sélecteurs imbriqués), d\u0026rsquo;import/export, et surtout, la possibilité de splitter facilement ses fichiers pendant le développement en font un outil puissant.\nC\u0026rsquo;est bien rangé, c\u0026rsquo;est beau.\nPour la production Sass compile notre code en un seul fichier CSS standard.\nEt surtout, Sass est facile à apprendre et nous permet d\u0026rsquo;y aller à notre rythme, car on peut tout à fait mélanger la syntaxe CSS classique et le SCSS.\nSi vous utilisez ou prévoyez d\u0026rsquo;utiliser Sass, pour l\u0026rsquo;importation, @use est désormais préféré à @import, et ce pour plusieurs raisons, entre autres :\nUtilisation : Introduit comme remplacement de @import, @use est une manière plus moderne et puissante d\u0026rsquo;inclure des fichiers Sass. Il est conçu pour résoudre de nombreux problèmes associés à @import. Comportement : Il charge les styles, variables, fonctions et mixins d\u0026rsquo;un autre fichier Sass. Une fois qu\u0026rsquo;un fichier est utilisé avec @use, il devient un \u0026ldquo;module\u0026rdquo;, et ses membres (variables, mixins, \u0026gt; etc.) sont uniquement accessibles sous un espace de noms par défaut, ce qui aide à prévenir les conflits de nommage. Avantages : @use n\u0026rsquo;inclut le fichier qu\u0026rsquo;une seule fois, peu importe le nombre de fois qu\u0026rsquo;il est utilisé, évitant ainsi les CSS en double. Il offre également une meilleure encapsulation et une \u0026gt; meilleure clarté quant à l\u0026rsquo;origine des différents styles et fonctions. Pour faire simple, oubliez @import.\nSASS, SCSS, Qu\u0026rsquo;est-ce donc cette diablerie ? La différence entre SASS et SCSS tient essentiellement à leur syntaxe respective.\nSass n\u0026rsquo;utilise pas les crochets ni les points-virgules, mais à la manière de Python utilise l\u0026rsquo;indentation.\nSyntaxe indentée\nSyntaxe apparue plus tard et très largement adoptée.\nSCSS (Sassy CSS) a été ajoutée à Sass pour plusieurs raisons clés, visant à améliorer l\u0026rsquo;expérience de développement et la compatibilité avec le CSS existant\nCompatible avec le CSS standard. Cela signifie que tout fichier CSS valide est également un fichier SCSS valide. Cette compatibilité facilite l\u0026rsquo;intégration de Sass dans des projets existants sans avoir besoin de réécrire le CSS existant.\nDe fait une syntaxe très similaire à celle du CSS standard, il est facile d\u0026rsquo;apprendre et d\u0026rsquo;adopter SCSS. Permet aux développeurs de commencer à utiliser Sass de manière graduelle. Ils peuvent commencer par écrire du CSS standard et introduire progressivement des fonctionnalités SCSS au besoin.\nPersonnellement, et comme beaucoup, je préfère la syntaxe SCSS.\nLes mixins C\u0026rsquo;est une fonctionnalité puissante qui permet de créer des groupes de déclarations CSS que l\u0026rsquo;on peut réutiliser comme bon nous semble.\nComme un exemple vaut 1000 mots : Comme illustré dans l\u0026rsquo;exemple ci-dessus, les mixins de Sass offrent une flexibilité et une puissance remarquables pour la gestion des styles CSS.\nIls permettent de regrouper plusieurs propriétés CSS sous un seul nom de mixin, que l\u0026rsquo;on peut ensuite réutiliser facilement.\nC\u0026rsquo;est particulièrement utile pour des motifs de style récurrents (boutons personnalisés, configuration flex ou grid\u0026hellip;). En plus les mixins peuvent accepter des arguments, ce qui permet une adaptation dynamique des styles.\nRègles imbriquées Personnellement je n\u0026rsquo;utilise pas (ou peu) les règles imbriquées car je trouve que ça complexifie le code et le rend moins lisible, alors qu\u0026rsquo;avec sass je veux faire l\u0026rsquo;inverse.\nRègles imbriquées\nSans compter que si je souhaite rapidement chercher \u0026ldquo;.navbar li\u0026rdquo;, je ne trouverai rien.\nCertains adorent, ce n\u0026rsquo;est pas mon cas. A vous de tester!\nPour installer Sass avec Node.js (installation globale)\nnpm install -g sass Sous Windows si vous utilisez Chocolatey\nchoco install sass Avec Homebrew, pour les utilisateurs de MacOS ou Linux\nbrew install sass/sass/sass A noter qu\u0026rsquo;il existe 2 version de Sass, une version en pur JavaScript et une version Dart un peu plus rapide.\n","permalink":"https://hub.visualartisan.fr/posts/sass/","summary":"Je rencontrais souvent sur CodePen du SASS, SCSS , Less, Stylus etc.\nJ\u0026rsquo;avais une idée générale que cela représentait une autre syntaxe CSS, sans jamais m\u0026rsquo;y être vraiment intéressé et faute d\u0026rsquo;y voir un intérêt immédiat pour mes projets.\nUne fois lancé dans des projets plus complexes, je me suis dit que ce serait bien de séparer mon CSS, afin d\u0026rsquo;avoir une meilleure lisibilité et une meilleure gestion. Ce sont les principales raisons qui m\u0026rsquo;ont poussé à essayer un préprocesseur CSS.","title":"Sass, du CSS, mais en mieux"},{"content":"\rS\u0026rsquo;il y a une chose avec React que j\u0026rsquo;avais du mal à comprendre, ce sont les mises à jour d\u0026rsquo;état et surtout la nature asynchrone de ces mises à jour. Je n\u0026rsquo;arrivais pas à y voir clair et bien comprendre ce qui se passait behind the scenes. C\u0026rsquo;est à dire : quand est-ce que l\u0026rsquo;état était réellement mis à jour ? Quand les composants étaient-ils rendus ? et surtout pourquoi ça fonctionnait ainsi.\nJe les utilisais, ça fonctionnait, mais sans vraiment comprendre.\nPour commencer prenons la fonction fetchMovies() qui contient des mises à jour d\u0026rsquo;état.\nUne fois le composant monté et la fonction fetchMovies() exécutée, que vont afficher les deux console.log() ?\ntrue/false ? true/true ? false/false ? export default function MonComposant()\r{\rconst [movies, setMovies] = useState([]);\rconst [isLoading, setIsLoading] = useState(false);\ruseEffect(function () {\rasync function fetchMovies() {\rsetIsLoading(true);\rconsole.log(isLoading);\rconst res = await fetch(\r`http://www.omdbapi.com/?apikey=${KEY}\u0026amp;s=${query}`\r);\rconst data = await res.json();\rsetMovies(data.Search);\rsetIsLoading(false);\rconsole.log(isLoading);\r}\rfetchMovies();\r}, []);\r... La bonne réponse est 3. false/false.\nMais pourquoi ? Ceci tient au fait que React planifie et batch les mises à jour d\u0026rsquo;état.\nPlanifie : les mises à jour d\u0026rsquo;état ne sont pas executées directement mais planifiées, elles sont en file d\u0026rsquo;attente, pour ainsi dire. Ceci est valable que vous ayez une mise à jour d\u0026rsquo;état ou plusieurs.\nBatch : React va regrouper toutes les mises à jour d\u0026rsquo;état (pour optimiser les performances). Si vous avez plusieurs appels à setState dans le même bloc de code, React les \u0026ldquo;regroupe\u0026rdquo; et les planifie pour s\u0026rsquo;exécuter après la fin de l\u0026rsquo;exécution du bloc de code.\nC\u0026rsquo;est la raison pour laquelle, après setIsLoading(true) console.log(isLoading) affiche false : à ce moment, l\u0026rsquo;état n\u0026rsquo;est pas encore mis à jour.\nA noter : le batching ne garantit pas que toutes les mises à jour d\u0026rsquo;état se produiront dans un seul rendu dans tous les cas. Il y a des exceptions, notamment avec des mises à jour d\u0026rsquo;état déclenchées dans certains contextes.\nMises à jour d\u0026rsquo;état dans les fonctions imbriquées Lorsque vous avez des mises à jour d\u0026rsquo;état dans des fonctions imbriquées, le même principe s\u0026rsquo;applique. React attend la fin de l\u0026rsquo;exécution de l\u0026rsquo;ensemble du contexte d\u0026rsquo;exécution avant de procéder aux mises à jour d\u0026rsquo;état.\nCela signifie que même si vous avez des mises à jour d\u0026rsquo;état dans des fonctions imbriquées ou des callbacks, React les regroupe et les applique en une seule fois à la fin de l\u0026rsquo;exécution du contexte englobant.\nfunction someFunction() {\r// du code\r// Mise à jour d\u0026#39;état 1\rsetSomeState(newValue);\rfunction nestedFunction() {\r// du code\r// Mise à jour d\u0026#39;état 2\rsetAnotherState(anotherValue);\r}\rnestedFunction();\r// Mise à jour d\u0026#39;état 3\rsetYetAnotherState(yetAnotherValue);\r} Dans cet exemple, setSomeState, setAnotherState et setYetAnotherState sont toutes planifiées pour être mises à jour après la fin de l\u0026rsquo;exécution de someFunction, y compris l\u0026rsquo;exécution de nestedFunction. Il n\u0026rsquo;y aura pas de rendus séparés pour chaque mise à jour d\u0026rsquo;état, au lieu de cela, un seul rendu qui reflètera toutes ces mises à jour se produira.\nRevenons à la fonction fetchMovies() Avec ces élements et si on suit le déroulement de l\u0026rsquo;execution, on peut avoir du mal à comprendre quand se produit la mise à jour de l\u0026rsquo;état et quand notre loader qui dépend de l\u0026rsquo;état de Loading va etre déclenché.\nasync function fetchMovies() Notre fonction s\u0026rsquo;execute\nsetIsLoading(true); La mise à jour d\u0026rsquo;état est planifiée.\nMais alors ? Si notre loader dépend de cet état et qu\u0026rsquo;il est toujours à false quand va t\u0026rsquo;il démarrer ?\nconst res = await fetch(\r`http://www.omdbapi.com/?apikey=${KEY}\u0026amp;s=${query}`\r);\rconst data = await res.json(); await fetch(...) est exécutée. Le mot-clé await met en pause l\u0026rsquo;exécution de fetchMovies jusqu\u0026rsquo;à ce que la promesse retournée par fetch soit résolue.\nPendant cette pause, le moteur JavaScript ne reste pas inactif, il peut exécuter d\u0026rsquo;autres tâches, y compris des rendus React.\nEt ceci n\u0026rsquo;est finalement pas spécifique à React, c\u0026rsquo;est le fonctionnement normal de JavaScript \u0026ldquo;vanilla\u0026rdquo;.\nPendant que la requête fetch est en attente, React en profite donc pour mettre à jour l\u0026rsquo;état et procéder au rendu du composant.\nUne fois la requête fetch terminée, la fonction fetchMovies reprend son exécution normale là ou elle s\u0026rsquo;est arrêtée. La suite s\u0026rsquo;exécute, y compris la nouvelle mise à jour de l\u0026rsquo;état avec setIsLoading(false) qui démontera le composant.\nCe qu\u0026rsquo;il faut retenir, c\u0026rsquo;est que même si le code est écrit de manière linéaire, les fonctions asynchrone et le système de rendu de React permettent des comportements plus complexes pas forcément visibles ni évidents.\nA noter que depuis React 18 tout est batché (event handler, timeout, promises, et les evenements natifs)\n","permalink":"https://hub.visualartisan.fr/posts/reactstatehook/","summary":"S\u0026rsquo;il y a une chose avec React que j\u0026rsquo;avais du mal à comprendre, ce sont les mises à jour d\u0026rsquo;état et surtout la nature asynchrone de ces mises à jour. Je n\u0026rsquo;arrivais pas à y voir clair et bien comprendre ce qui se passait behind the scenes. C\u0026rsquo;est à dire : quand est-ce que l\u0026rsquo;état était réellement mis à jour ? Quand les composants étaient-ils rendus ? et surtout pourquoi ça fonctionnait ainsi.","title":"React - Mises à jour d'état"}]