<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SASS : du CSS, mais en mieux | { VisualArtisan }</title>
<meta name="keywords" content="sass, scss, css, preprocessor, mixin">
<meta name="description" content="https://sass-lang.com/
Lors de mes pérégrinations sur CodePen, je tombais souvent sur des exemples utilisant SASS, SCSS, mais aussi Less, Stylus, et d&rsquo;autres&hellip;
C&rsquo;était un peu obscur. J&rsquo;avais plus ou moins compris que les autres syntaxes CSS offraient des fonctionnalités additionnelles, mais pour moi, le CSS standard me semblait suffisant.
L&rsquo;idée d&rsquo;utiliser des outils supplémentaires ne me paraissait pas pertinente, j&rsquo;étais déjà bien occupé avec le CSS traditionnel. Je me disais que ces outils n&rsquo;étaient pas pour moi et qu&rsquo;ils allaient simplement ajouter une couche de complexité à mon code.">
<meta name="author" content="">
<link rel="canonical" href="https://hub.visualartisan.fr/posts/sass/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hub.visualartisan.fr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hub.visualartisan.fr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hub.visualartisan.fr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hub.visualartisan.fr/apple-touch-icon.png">
<link rel="mask-icon" href="https://hub.visualartisan.fr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="SASS : du CSS, mais en mieux" />
<meta property="og:description" content="https://sass-lang.com/
Lors de mes pérégrinations sur CodePen, je tombais souvent sur des exemples utilisant SASS, SCSS, mais aussi Less, Stylus, et d&rsquo;autres&hellip;
C&rsquo;était un peu obscur. J&rsquo;avais plus ou moins compris que les autres syntaxes CSS offraient des fonctionnalités additionnelles, mais pour moi, le CSS standard me semblait suffisant.
L&rsquo;idée d&rsquo;utiliser des outils supplémentaires ne me paraissait pas pertinente, j&rsquo;étais déjà bien occupé avec le CSS traditionnel. Je me disais que ces outils n&rsquo;étaient pas pour moi et qu&rsquo;ils allaient simplement ajouter une couche de complexité à mon code." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hub.visualartisan.fr/posts/sass/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-05T09:10:22+01:00" />
<meta property="article:modified_time" content="2023-12-05T09:10:22+01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SASS : du CSS, mais en mieux"/>
<meta name="twitter:description" content="https://sass-lang.com/
Lors de mes pérégrinations sur CodePen, je tombais souvent sur des exemples utilisant SASS, SCSS, mais aussi Less, Stylus, et d&rsquo;autres&hellip;
C&rsquo;était un peu obscur. J&rsquo;avais plus ou moins compris que les autres syntaxes CSS offraient des fonctionnalités additionnelles, mais pour moi, le CSS standard me semblait suffisant.
L&rsquo;idée d&rsquo;utiliser des outils supplémentaires ne me paraissait pas pertinente, j&rsquo;étais déjà bien occupé avec le CSS traditionnel. Je me disais que ces outils n&rsquo;étaient pas pour moi et qu&rsquo;ils allaient simplement ajouter une couche de complexité à mon code."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://hub.visualartisan.fr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "SASS : du CSS, mais en mieux",
      "item": "https://hub.visualartisan.fr/posts/sass/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SASS : du CSS, mais en mieux",
  "name": "SASS : du CSS, mais en mieux",
  "description": "https://sass-lang.com/\nLors de mes pérégrinations sur CodePen, je tombais souvent sur des exemples utilisant SASS, SCSS, mais aussi Less, Stylus, et d\u0026rsquo;autres\u0026hellip;\nC\u0026rsquo;était un peu obscur. J\u0026rsquo;avais plus ou moins compris que les autres syntaxes CSS offraient des fonctionnalités additionnelles, mais pour moi, le CSS standard me semblait suffisant.\nL\u0026rsquo;idée d\u0026rsquo;utiliser des outils supplémentaires ne me paraissait pas pertinente, j\u0026rsquo;étais déjà bien occupé avec le CSS traditionnel. Je me disais que ces outils n\u0026rsquo;étaient pas pour moi et qu\u0026rsquo;ils allaient simplement ajouter une couche de complexité à mon code.",
  "keywords": [
    "sass", "scss", "css", "preprocessor", "mixin"
  ],
  "articleBody": "\rhttps://sass-lang.com/\nLors de mes pérégrinations sur CodePen, je tombais souvent sur des exemples utilisant SASS, SCSS, mais aussi Less, Stylus, et d’autres…\nC’était un peu obscur. J’avais plus ou moins compris que les autres syntaxes CSS offraient des fonctionnalités additionnelles, mais pour moi, le CSS standard me semblait suffisant.\nL’idée d’utiliser des outils supplémentaires ne me paraissait pas pertinente, j’étais déjà bien occupé avec le CSS traditionnel. Je me disais que ces outils n’étaient pas pour moi et qu’ils allaient simplement ajouter une couche de complexité à mon code. Surtout que le prix à payer était cher : apprendre une nouvelle syntaxe. C’est pour ces raisons que je ne m’y étais jamais réellement intéressé. Je me trompais.\nPlus tard, avec davantage d’expérience et engagé dans des projets un peu plus complexes, j’ai réalisé l’importance de séparer et d’organiser mon CSS pour une meilleure lisibilité et une meilleure gestion. À ce moment, j’ai compris que j’allais avoir besoin de plus que ce que le CSS standard pouvait offrir. Cela m’a incité à explorer les préprocesseurs CSS.\nMon choix s’est arrêté sur SASS, et j’ai immédiatement accroché !\nUn préprocesseur CSS, dont vous ne pourrez plus vous passer! Son système de variables, bien que similaire à certaines fonctionnalités du CSS vanilla, son système de mixins, de nesting (sélecteurs imbriqués), d’import/export, et surtout, la possibilité de splitter facilement ses fichiers pendant le développement en font un outil puissant.\nC’est bien rangé, c’est beau.\nPour la production SASS compile notre code en un seul fichier CSS standard.\nEt surtout, Sass est facile à apprendre et nous permet d’y aller à notre rythme, car on peut tout à fait mélanger la syntaxe CSS classique et le SCSS.\nNote: Si vous utilisez ou prévoyez d’utiliser Sass, pour l’importation, @use est désormais préféré à @import, et ce pour plusieurs raisons, entre autres :\nUtilisation : Introduit comme remplacement de @import, @use est une manière plus moderne et puissante d’inclure des fichiers Sass. Il est conçu pour résoudre de nombreux problèmes associés à @import. Comportement : Il charge les styles, variables, fonctions et mixins d’un autre fichier Sass. Une fois qu’un fichier est utilisé avec @use, il devient un “module”, et ses membres (variables, mixins, \u003e etc.) sont uniquement accessibles sous un espace de noms par défaut, ce qui aide à prévenir les conflits de nommage. Avantages : @use n’inclut le fichier qu’une seule fois, peu importe le nombre de fois qu’il est utilisé, évitant ainsi les CSS en double. Il offre également une meilleure encapsulation et une \u003e meilleure clarté quant à l’origine des différents styles et fonctions. Pour faire simple, oubliez @import.\nSASS, SCSS, Qu’est-ce donc cette diablerie ? La différence entre SASS et SCSS tient essentiellement à leur syntaxe respective.\nSass n’utilise pas les accolades ni les points-virgules, mais à la manière de Python utilise l’indentation.\nSyntaxe indentée\nSyntaxe apparue plus tard et très largement adoptée.\nSCSS (Sassy CSS) a été ajoutée à Sass pour plusieurs raisons clés, visant à améliorer l’expérience de développement et la compatibilité avec le CSS existant\nCompatible avec le CSS standard. Cela signifie que tout fichier CSS valide est également un fichier SCSS valide. Cette compatibilité facilite l’intégration de Sass dans des projets existants sans avoir besoin de réécrire le CSS existant.\nDe fait, il est facile d’apprendre et d’adopter SCSS. Permet aux développeurs de commencer à utiliser Sass de manière graduelle. Ils peuvent commencer par écrire du CSS standard et introduire progressivement des fonctionnalités SCSS au besoin.\nPersonnellement, et comme beaucoup, je préfère la syntaxe SCSS.\nLes mixins C’est une fonctionnalité puissante qui permet de créer des groupes de déclarations CSS que l’on peut réutiliser comme bon nous semble.\nComme un exemple vaut 1000 mots : Comme illustré dans l’exemple ci-dessus, les mixins de Sass offrent une flexibilité et une puissance remarquables pour la gestion des styles CSS.\nIls permettent de regrouper plusieurs propriétés CSS sous un seul nom de mixin, que l’on peut ensuite réutiliser facilement.\nC’est particulièrement utile pour des motifs de style récurrents (boutons personnalisés, configuration flex ou grid…). En plus les mixins peuvent accepter des arguments, ce qui permet une adaptation dynamique des styles.\nRègles imbriquées Personnellement je n’utilise pas (ou peu) les règles imbriquées car je trouve que ça complexifie le code et le rend moins lisible, alors qu’avec sass je veux faire l’inverse.\nRègles imbriquées\nSans compter que si je souhaite rapidement chercher “.navbar li”, je ne trouverai rien.\nCertains adorent, ce n’est pas mon cas. A vous de tester!\nPour installer SASS avec Node.js (installation globale)\nnpm install -g sass Sous Windows si vous utilisez Chocolatey\nchoco install sass Avec Homebrew, pour les utilisateurs de MacOS ou Linux\nbrew install sass/sass/sass A noter qu’il existe plusieurs versions de Sass, notamment une version en pur JavaScript et une version Dart un peu plus rapide.\n",
  "wordCount" : "801",
  "inLanguage": "en",
  "datePublished": "2023-12-05T09:10:22+01:00",
  "dateModified": "2023-12-05T09:10:22+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hub.visualartisan.fr/posts/sass/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "{ VisualArtisan }",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hub.visualartisan.fr/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hub.visualartisan.fr/" accesskey="h" title="{ VisualArtisan } (Alt + H)">{ VisualArtisan }</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      SASS : du CSS, mais en mieux
    </h1>
    <div class="post-meta"><span title='2023-12-05 09:10:22 +0100 CET'>December 5, 2023</span>

</div>
  </header> 
  <div class="post-content"><p><img loading="lazy" src="/img/posts/sass/sasscover.jpg" alt="sass article cover"  />

<a href="https://sass-lang.com/">https://sass-lang.com/</a></p>
<p>Lors de mes pérégrinations sur <a href="https://codepen.io/">CodePen</a>, je tombais souvent sur des exemples utilisant SASS, SCSS, mais aussi Less, Stylus, et d&rsquo;autres&hellip;</p>
<p>C&rsquo;était un peu obscur. J&rsquo;avais plus ou moins compris que les autres syntaxes CSS offraient des fonctionnalités additionnelles, mais pour moi, le CSS standard me semblait suffisant.</p>
<p>L&rsquo;idée d&rsquo;utiliser des outils supplémentaires ne me paraissait pas pertinente, j&rsquo;étais déjà bien occupé avec le CSS traditionnel. Je me disais que ces outils n&rsquo;étaient pas pour moi et qu&rsquo;ils allaient simplement ajouter une couche de complexité à mon code. Surtout que le prix à payer était cher : apprendre une nouvelle syntaxe.
C&rsquo;est pour ces raisons que je ne m&rsquo;y étais jamais réellement intéressé. Je me trompais.</p>
<p>Plus tard, avec davantage d&rsquo;expérience et engagé dans des projets un peu plus complexes, j&rsquo;ai réalisé l&rsquo;importance de séparer et d&rsquo;organiser mon CSS pour une meilleure lisibilité et une meilleure gestion. À ce moment, j&rsquo;ai compris que j&rsquo;allais avoir besoin de plus que ce que le CSS standard pouvait offrir. Cela m&rsquo;a incité à explorer les préprocesseurs CSS.</p>
<p>Mon choix s&rsquo;est arrêté sur SASS, et j&rsquo;ai immédiatement accroché !</p>
<h3 id="un-préprocesseur-css-dont-vous-ne-pourrez-plus-vous-passer">Un préprocesseur CSS, dont vous ne pourrez plus vous passer!<a hidden class="anchor" aria-hidden="true" href="#un-préprocesseur-css-dont-vous-ne-pourrez-plus-vous-passer">#</a></h3>
<p>Son système de variables, bien que similaire à certaines fonctionnalités du CSS vanilla, son système de mixins, de nesting (sélecteurs imbriqués), d&rsquo;import/export, et surtout, la possibilité de splitter facilement ses fichiers pendant le développement en font un outil puissant.</p>
<p>C&rsquo;est bien rangé, c&rsquo;est beau.</p>
<p><img loading="lazy" src="/img/posts/sass/sass1.png" alt="sass"  />
</p>
<p><em>Pour la production SASS compile notre code en un seul fichier CSS standard.</em></p>
<p>Et surtout, Sass est facile à apprendre et nous permet d&rsquo;y aller à notre rythme, car on peut tout à fait mélanger la syntaxe CSS classique et le SCSS.</p>
<blockquote>
<p>Note: Si vous utilisez ou prévoyez d&rsquo;utiliser Sass, pour l&rsquo;importation, @use est désormais préféré à @import, et ce pour plusieurs raisons, entre autres :</p>
<ul>
<li><strong>Utilisation</strong> : Introduit comme remplacement de <code>@import</code>, <code>@use</code> est une manière plus moderne et puissante d&rsquo;inclure des fichiers Sass. Il est conçu pour résoudre de nombreux problèmes associés à <code>@import</code>.</li>
<li><strong>Comportement</strong> : Il charge les styles, variables, fonctions et mixins d&rsquo;un autre fichier Sass. Une fois qu&rsquo;un fichier est utilisé avec <code>@use</code>, il devient un &ldquo;module&rdquo;, et ses membres (variables, mixins, &gt; etc.) sont uniquement accessibles sous un espace de noms par défaut, ce qui aide à prévenir les conflits de nommage.</li>
<li><strong>Avantages</strong> : <code>@use</code> n&rsquo;inclut le fichier qu&rsquo;une seule fois, peu importe le nombre de fois qu&rsquo;il est utilisé, évitant ainsi les CSS en double. Il offre également une meilleure encapsulation et une &gt; meilleure clarté quant à l&rsquo;origine des différents styles et fonctions.</li>
</ul>
</blockquote>
<p>Pour faire simple, oubliez @import.</p>
<h3 id="sass-scss-quest-ce-donc-cette-diablerie-">SASS, SCSS, Qu&rsquo;est-ce donc cette diablerie ?<a hidden class="anchor" aria-hidden="true" href="#sass-scss-quest-ce-donc-cette-diablerie-">#</a></h3>
<p>La différence entre SASS et SCSS tient essentiellement à leur syntaxe respective.</p>
<p>Sass n&rsquo;utilise pas les accolades ni les points-virgules, mais à la manière de Python utilise l&rsquo;indentation.</p>
<p><img loading="lazy" src="/img/posts/sass/sass2.png" alt="sass"  />

<em>Syntaxe indentée</em></p>
<p><img loading="lazy" src="/img/posts/sass/sass3.png" alt="sass"  />

<em>Syntaxe apparue plus tard et très largement adoptée.</em></p>
<p>SCSS (Sassy CSS) a été ajoutée à Sass pour plusieurs raisons clés, visant à améliorer l&rsquo;expérience de développement et la compatibilité avec le CSS existant</p>
<ul>
<li>
<p>Compatible avec le CSS standard. Cela signifie que tout fichier CSS valide est également un fichier SCSS valide. Cette compatibilité facilite l&rsquo;intégration de Sass dans des projets existants sans avoir besoin de réécrire le CSS existant.</p>
</li>
<li>
<p>De fait, il est facile d&rsquo;apprendre et d&rsquo;adopter SCSS. Permet aux développeurs de commencer à utiliser Sass de manière graduelle. Ils peuvent commencer par écrire du CSS standard et introduire progressivement des fonctionnalités SCSS au besoin.</p>
</li>
</ul>
<p>Personnellement, et comme beaucoup, je préfère la syntaxe SCSS.</p>
<h3 id="les-mixins">Les mixins<a hidden class="anchor" aria-hidden="true" href="#les-mixins">#</a></h3>
<p>C&rsquo;est une fonctionnalité puissante qui permet de créer des groupes de déclarations CSS que l&rsquo;on peut réutiliser comme bon nous semble.</p>
<p>Comme un exemple vaut 1000 mots :
<img loading="lazy" src="/img/posts/sass/mixin.png" alt="sass"  />
</p>
<p>Comme illustré dans l&rsquo;exemple ci-dessus, les mixins de Sass offrent une flexibilité et une puissance remarquables pour la gestion des styles CSS.</p>
<p>Ils permettent de regrouper plusieurs propriétés CSS sous un seul nom de mixin, que l&rsquo;on peut ensuite réutiliser facilement.</p>
<p>C&rsquo;est particulièrement utile pour des motifs de style récurrents (boutons personnalisés, configuration flex ou grid&hellip;). En plus les mixins peuvent accepter des arguments, ce qui permet une adaptation dynamique des styles.</p>
<h3 id="règles-imbriquées">Règles imbriquées<a hidden class="anchor" aria-hidden="true" href="#règles-imbriquées">#</a></h3>
<p>Personnellement je n&rsquo;utilise pas (ou peu) les règles imbriquées car je trouve que ça complexifie le code et le rend moins lisible, alors qu&rsquo;avec sass je veux faire l&rsquo;inverse.</p>
<p><img loading="lazy" src="/img/posts/sass/sass4.png" alt="sass"  />
</p>
<p><img loading="lazy" src="/img/posts/sass/sass5.png" alt="sass"  />

<em>Règles imbriquées</em></p>
<p>Sans compter que si je souhaite rapidement chercher &ldquo;.navbar li&rdquo;, je ne trouverai rien.</p>
<p>Certains adorent, ce n&rsquo;est pas mon cas. A vous de tester!</p>
<h3 id="pour-installer-sass">Pour installer SASS<a hidden class="anchor" aria-hidden="true" href="#pour-installer-sass">#</a></h3>
<p>avec Node.js (installation globale)</p>
<pre tabindex="0"><code>npm install -g sass
</code></pre><p>Sous Windows si vous utilisez Chocolatey</p>
<pre tabindex="0"><code>choco install sass
</code></pre><p>Avec Homebrew, pour les utilisateurs de MacOS ou Linux</p>
<pre tabindex="0"><code>brew install sass/sass/sass
</code></pre><blockquote>
<p>A noter qu&rsquo;il existe plusieurs versions de Sass, notamment une version en pur JavaScript et une version Dart un peu plus rapide.</p>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://hub.visualartisan.fr/tags/sass/">sass</a></li>
      <li><a href="https://hub.visualartisan.fr/tags/scss/">scss</a></li>
      <li><a href="https://hub.visualartisan.fr/tags/css/">css</a></li>
      <li><a href="https://hub.visualartisan.fr/tags/preprocessor/">preprocessor</a></li>
      <li><a href="https://hub.visualartisan.fr/tags/mixin/">mixin</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://hub.visualartisan.fr/posts/reactstatehook/">
    <span class="title">Next »</span>
    <br>
    <span>React - Mises à jour d&#39;état</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hub.visualartisan.fr/">{ VisualArtisan }</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
